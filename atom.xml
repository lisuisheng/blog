<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsuis的博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://lisuisheng.github.io/blog/"/>
  <updated>2019-03-15T10:19:25.743Z</updated>
  <id>http://lisuisheng.github.io/blog/</id>
  
  <author>
    <name>Lsuis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>concurrent&amp;amp;parallel</title>
    <link href="http://lisuisheng.github.io/blog/2019/03/15/concurrent&amp;parallel/"/>
    <id>http://lisuisheng.github.io/blog/2019/03/15/concurrent&amp;parallel/</id>
    <published>2019-03-15T02:17:11.135Z</published>
    <updated>2019-03-15T10:19:25.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一文理解进程与线程的常见概念"><a href="#一文理解进程与线程的常见概念" class="headerlink" title="一文理解进程与线程的常见概念"></a>一文理解进程与线程的常见概念</h3><p>首先，进程和线程都是针对CPU工作时间段的描述。下面来看一下它们之间的区别。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是一个程序运行的时候被CPU抽象出来的概念，一个程序运行后被抽象为一个进程。当计算机执行一个程序的时候，必然会产生一个进程。也就是说，一个程序的执行<strong>至少有一个进程</strong>。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程至少拥有一个线程。线程的划分尺度小于进程，使得多线程程序具有更高的并发性。在一个进程中，可能被划分为多个线程，它可以与同进程中的其他线程共享数据。在进程中，有些程序流程块是可以乱序执行的，并且这个代码块可以同时被多次执行。实际上，这样的代码块就是线程体。线程是进程中乱序执行的代码流程。</p><blockquote><p>通过栗子了解进程和线程的特点：<br>进程 -&gt; 火车<br>线程 -&gt; 车厢</p><ol><li>一列火车可能有多个车厢（一个进程可以有多个线程）</li><li>乘客不能在行驶中从一列火车跳到另一列上（进程间数据不共享）</li><li>乘客可以在一列火车上去往各个车厢（同一进程下的线程数据共享）</li><li>一列火车抛锚了不影响另外一列火车，但是一节车厢断掉了会影响一整列火车（进程间不会相互影响，但一个线程挂掉会导致整个进程奔溃）</li></ol></blockquote><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p>在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。目前的大多数计算机的操作系统都是多任务系统，能够管理多个进程的运行。这些任务之间互相不受影响，例如我们可以一边上网，一边打印文档。</p><p>当然，说到这里，还应谈及到并行与并发。对于计算机来说，一个单核的CPU原则上只能同时执行一个任务（进程）。假设CPU上有多个核的话，就可以同时执行多个任务。例如，4核的CPU可以同时执行4个任务（进程）。一个核执行一个任务，4个任务同时执行这个时候就叫做并行处理。</p><p>但是在实际上，我们计算机的CPU性能是非常的强大，强大到其他硬件的运行速度都只能望其项背。在执行任务当中，CPU处理任务的时间是非常短的。假设出现一个CPU处理一个任务的时候，此时CPU大多数的时间都处于空闲状态（实际上是在等待其他硬件执行操作），从而造成性能资源大大的浪费。</p><p>因此，并发处理成为了充分利用CPU资源的手段。当多个线程同时运行的时候，这样的执行模式称为并发处理。简单并发处理的算法如“时间片轮转进程调度算法”，它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。</p><p>简单的总结一下，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。<br><img src="/blog/img/concurrent&amp;parallel.jpg" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Hyperledger基本概念及环境部署</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/13/hyperledgerConcept/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/13/hyperledgerConcept/</id>
    <published>2019-02-13T07:44:09.000Z</published>
    <updated>2019-02-13T11:51:55.589Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="区块链学习笔记"><a href="#区块链学习笔记" class="headerlink" title="区块链学习笔记"></a>区块链学习笔记</h2><h3 id="共享账本"><a href="#共享账本" class="headerlink" title="共享账本"></a>共享账本</h3><ol><li>世界状态：描述账本特定时间点的状态，是账本的数据库。</li><li>交易记录：记录产生世界状态当前值的所有交易，是世界状态的更新历史。</li><li>账本：世界状态数据库和交易历史记录的集合。</li></ol><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><ol><li>chaincode</li><li>只访问账本的数据库组件和世界状态，不会查询交易记录。目前支持语言：GO</li></ol><h3 id="fabric环境配置"><a href="#fabric环境配置" class="headerlink" title="fabric环境配置"></a>fabric环境配置</h3><ol><li>Git</li><li>Go - 1.10.x版本</li><li>Docker - 17.06.2-ce版本或以上</li><li>Docker Compose - 1.14.0版本或以上</li><li>Pip 安装方法：sudo apt-get install python-pip</li><li>过高的docker和docker-compose环境和fabric1.0不兼容</li><li>fabric v1.0.0 使用 Docker - 17.06.2-ce， docker-compose - 1.12.0</li><li>ubuntu系统有兼容问题？？</li></ol><h3 id="go环境的配置"><a href="#go环境的配置" class="headerlink" title="go环境的配置"></a>go环境的配置</h3><ol><li><p>下载golang：</p><pre><code>https://studygolang.com/dl</code></pre></li><li><p>解压并移动到/usr/local/go中</p><pre><code>sudo tar -zvxf go1.6.2.linux-amd64.tar.gzsudo mv go /usr/local/go</code></pre></li><li><p>设置环境变量</p><pre><code>sudo gedit /etc/profileexport GOROOT=/usr/local/go  #设置为go安装的路径export GOPATH=$HOME/gocode   #默认安装包的路径export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code></pre></li><li><p>应用环境</p><pre><code>source /etc/profile</code></pre></li></ol><h3 id="拉取Fabric源码"><a href="#拉取Fabric源码" class="headerlink" title="拉取Fabric源码"></a>拉取Fabric源码</h3><pre><code>git clone https://github.com/hyperledger/fabric.git</code></pre><h3 id="编译configtxgen工具"><a href="#编译configtxgen工具" class="headerlink" title="编译configtxgen工具"></a>编译configtxgen工具</h3><pre><code>cd $GOPATH/src/github.com/hyperledger/fabricmake configtxgen# 如果出错：&apos;ltdl.h&apos; file not foundsudo apt install libtool libltdl-dev# 然后再运行makemake configtxgen</code></pre><h3 id="测试e2e-cli"><a href="#测试e2e-cli" class="headerlink" title="测试e2e_cli"></a>测试e2e_cli</h3><ol><li><p>执行如下脚本：</p><pre><code>./network_setup.sh up</code></pre></li></ol><pre><code>这个做了如下操作：1. 编译生成Fabric公私钥、证书的程序，程序在目录：fabric/release/linux-amd64/bin2. 基于configtx.yaml生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。3. 基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中。4. 基于docker-compose-cli.yaml启动1Orderer+4Peer+1CLI的Fabric容器。5. 在CLI启动的时候，会运行scripts/script.sh文件，这个脚本文件包含了创建Channel，加入Channel，安装Example02，运行Example02等功能。</code></pre><p><img src="/blog/img/区块链技术实现.png" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="区块链" scheme="http://lisuisheng.github.io/blog/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>关于使用hexo框架站内搜索的一些坑</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/13/searhPlugsDebug/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/13/searhPlugsDebug/</id>
    <published>2019-02-13T06:25:50.000Z</published>
    <updated>2019-02-13T14:31:07.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="搜索功能不能使用，提示content-json文件找不到"><a href="#搜索功能不能使用，提示content-json文件找不到" class="headerlink" title="搜索功能不能使用，提示content.json文件找不到"></a>搜索功能不能使用，提示content.json文件找不到</h2><p>一般出现这个错误的原因有两个：</p><h3 id="1-没有安装hexo-generator-json-content插件"><a href="#1-没有安装hexo-generator-json-content插件" class="headerlink" title="1. 没有安装hexo-generator-json-content插件"></a>1. 没有安装hexo-generator-json-content插件</h3><p><strong>解决方法：</strong><br>进入<u><strong>博客的根目录</strong></u>，使用以下命令安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-generator-json-content -S</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：这个插件一定要在博客的根目录中安装</p><h3 id="2-config-yml配置不正确"><a href="#2-config-yml配置不正确" class="headerlink" title="2. _config.yml配置不正确"></a>2. _config.yml配置不正确</h3><p><strong>解决方法：</strong><br>在博客根目录的_config.yml或者主题目录下的_config.yml添加相对应的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 搜索</span><br><span class="line">jsonContent:</span><br><span class="line">  searchLocal: true</span><br><span class="line">  searchGoogle: false</span><br><span class="line">  posts:</span><br><span class="line">    title: true</span><br><span class="line">    text: true</span><br><span class="line">    content: true</span><br><span class="line">    categories: false</span><br><span class="line">    tags: false</span><br></pre></td></tr></table></figure></p><p><strong>请注意：</strong><br>博主看过很多网上的帖子和博客都说一定要把以上的 jsonContent 配置在根目录的 <code>_config.yml</code>。然而亲测并非如此，写在主题目录的 <code>_config.yml</code>一样生效。但是，以上的 jsonContent 的配置仅供参考，实际中要对应博客中的search.js文件配置，否则浏览器依然会报错。</p><h3 id="3-博客的目录结构问题"><a href="#3-博客的目录结构问题" class="headerlink" title="3. 博客的目录结构问题"></a>3. 博客的目录结构问题</h3><p>这个问题可能会出现在 <code>search.js</code>文件中，博主在debug的时候首先发现浏览器报错找不到 <code>content.json</code>文件，但是如果按照前两点的方法解决之后在我们使用命令 <code>hexo g</code>之后，在 public 目录下会自动生成 <code>content.json</code>文件。那么原因很有可能是执行 <code>search.js</code>中出的错误，紧接着浏览源码的时候留意到在加载 <code>content.json</code>中的路径不正确:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loadData(success) &#123;</span><br><span class="line">    if (!searchData) &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&apos;GET&apos;, &apos;/content.json&apos;, true);</span><br><span class="line">        </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p><strong>解决方法：</strong></p><ol><li>由于博主的博客是部署在子文件xxx/blog/下的，所以需将其改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loadData(success) &#123;</span><br><span class="line">    if (!searchData) &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&apos;GET&apos;, &apos;/blog/content.json&apos;, true);</span><br><span class="line">        </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><p>这样 <code>content.js</code>就可以顺利加载出来了。我们也会发现在浏览器预览的时候输入搜索条件也能正确显示搜索结果。<br><img src="/blog/img/successQuery.png" alt="images"><br>但此时如果点击搜索结果并不能正确的进入搜索结果页面。原因是最后拼接路径没有修改过来，因此继续在 <code>search.js</code>文件中修改对应的 path 路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function render(data) &#123;</span><br><span class="line">    var html = &apos;&apos;;</span><br><span class="line">    if (data.length) &#123;</span><br><span class="line">        html = data.map(function(post) &#123;</span><br><span class="line">            return tpl(searchTpl, &#123;</span><br><span class="line">                title: filter(post.title, &apos;title&apos;),</span><br><span class="line">                path: &apos;blog/&apos; + post.path,</span><br><span class="line">                content: filter(post.text, &apos;content&apos;)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>至此，本地搜索功能可以正常使用了。</p><ol start="2"><li>第二种解决的方案就是要把博客部署在根路径下，不要放在任何子文件夹下，只要和 <code>search.js</code>的路径对的上就没有问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mvc和mvvm</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/13/mvc&amp;&amp;mvvm/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/13/mvc&amp;&amp;mvvm/</id>
    <published>2019-02-13T06:24:07.000Z</published>
    <updated>2019-02-13T11:53:46.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MVC-和-MVVM-基本原理"><a href="#MVC-和-MVVM-基本原理" class="headerlink" title="MVC 和 MVVM 基本原理"></a>MVC 和 MVVM 基本原理</h2><h3 id="MVC–分层设计模型"><a href="#MVC–分层设计模型" class="headerlink" title="MVC–分层设计模型"></a>MVC–分层设计模型</h3><ul><li>M模型层：负责操作数据库，执行对应的SQL语句，进行数据的增删改查</li><li>V视图层：用户操作界面</li><li>C控制层：封装具体业务逻辑处理的逻辑代码，只负责处理业务</li></ul><h3 id="MVVM—-前端开发模型"><a href="#MVVM—-前端开发模型" class="headerlink" title="MVVM—-前端开发模型"></a>MVVM—-前端开发模型</h3><ul><li>M：从后台服务器返回到前端页面的数据集（单独某个页面）</li><li>VM（核心）：调度器，分割了M和V。主要思想是为了让开发更加方便，因为MVVM提供了数据的双向绑定。双向绑定是由VM提供。</li><li>V：页面HTML结构</li></ul><p>附上两种模型的原理图及关系</p><p><img src="/blog/img/MVC和MVVM的基本原理图.png" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2019最喜欢的一首歌～</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/12/qifengle/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/12/qifengle/</id>
    <published>2019-02-12T13:03:10.000Z</published>
    <updated>2019-03-15T08:46:59.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="aplayer-wJcjJEBs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[00:03.82]起风了-吴青峰[00:07.29]我曾将青春翻涌成她[00:10.72]也曾指尖弹出盛夏[00:14.06]心之所动 且就随缘去吧[00:45.34]这一路上走走停停[00:48.86]顺着少年漂流的痕迹[00:51.78]迈出车站的前一刻[00:55.13]竟有些犹豫[00:58.30]不禁笑这近乡情怯[01:01.46]仍无可避免[01:04.06]而长野的天[01:05.63]依旧那么暖[01:07.27]风吹起了从前[01:09.58]从前初识这世间[01:12.59]万般流连[01:14.42]看着天边似在眼前[01:17.50]也甘愿赴汤蹈火去走它一遍[01:22.73]如今走过这世间[01:25.59]万般流连[01:27.53]翻过岁月不同侧脸[01:30.56]措不及防闯入你的笑颜[01:36.32]我曾难自拔于世界之大[01:40.52]也沉溺于其中梦话[01:43.87]不得真假 不做挣扎 不惧笑话[01:49.41]我曾将青春翻涌成她[01:53.06]也曾指尖弹出盛夏[01:56.31]心之所动 且就随缘去吧[02:02.54]逆着光行走 任风吹雨打[02:19.44]短短的路走走停停[02:22.70]也有了几分的距离[02:25.86]不知抚摸的是故事 还是段心情[02:32.17]也许期待的不过是 与时间为敌[02:37.96]再次看到你[02:39.57]微凉晨光里[02:41.28]笑得很甜蜜[02:43.59]从前初识这世间[02:46.72]万般流连[02:48.43]看着天边似在眼前[02:51.67]也甘愿赴汤蹈火去走它一遍[02:56.60]如今走过这世间[02:59.73]万般流连[03:01.50]翻过岁月不同侧脸[03:04.59]措不及防闯入你的笑颜[03:13.58]我曾难自拔于世界之大[03:17.72]也沉溺于其中梦话[03:20.93]不得真假 不做挣扎 不惧笑话[03:26.85]我曾将青春翻涌成她[03:30.46]也曾指尖弹出盛夏[03:33.57]心之所动 且就随缘去吧[03:41.40]晚风吹起你鬓间的白发[03:45.34]抚平回忆留下的疤[03:48.61]你的眼中 明暗交杂 一笑生花[03:55.78]我仍感叹于世界之大[03:59.66]也沉醉于儿时情话[04:02.73]不剩真假 不做挣扎 无谓笑话[04:08.91]我终将青春还给了她[04:12.68]连同指尖弹出的盛夏[04:16.12]心之所动 就随风去了[04:21.71]以爱之名 你还愿意吗[04:33.26]爱你我的大白菜！</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-wJcjJEBs"),narrow: false,autoplay: true,showlrc: 2,music: {title: "起风了",author: "吴青峰",url: "http://poeg603m7.bkt.clouddn.com/1111.mp3",pic: "http://p1.music.126.net/aMVPsO00OqlVTS2yMH8RgA==/109951163785600029.jpg?param=130y130",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><blockquote><p>起风了</p><footer><strong>吴青峰</strong></footer></blockquote><p>我曾将青春翻涌成她<br>也曾指尖弹出盛夏<br>心之所动 且就随缘去吧<br>这一路上走走停停<br>顺着少年漂流的痕迹<br>迈出车站的前一刻<br>竟有些犹豫<br>不禁笑这近乡情怯<br>仍无可避免<br>而长野的天<br>依旧那么暖<br>风吹起了从前<br>从前初识这世间<br>万般流连<br>看着天边似在眼前<br>也甘愿赴汤蹈火去走它一遍<br>如今走过这世间<br>万般流连<br>翻过岁月不同侧脸<br>措不及防闯入你的笑颜<br>我曾难自拔于世界之大<br>也沉溺于其中梦话<br>不得真假 不做挣扎 不惧笑话<br>我曾将青春翻涌成她<br>也曾指尖弹出盛夏<br>心之所动 且就随缘去吧<br>逆着光行走 任风吹雨打<br>短短的路走走停停<br>也有了几分的距离<br>不知抚摸的是故事 还是段心情<br>也许期待的不过是 与时间为敌<br>再次看到你<br>微凉晨光里<br>笑得很甜蜜<br>从前初识这世间<br>万般流连<br>看着天边似在眼前<br>也甘愿赴汤蹈火去走它一遍<br>如今走过这世间<br>万般流连<br>翻过岁月不同侧脸<br>措不及防闯入你的笑颜<br>我曾难自拔于世界之大<br>也沉溺于其中梦话<br>不得真假 不做挣扎 不惧笑话<br>我曾将青春翻涌成她<br>也曾指尖弹出盛夏<br>心之所动 且就随缘去吧<br>晚风吹起你鬓间的白发<br>抚平回忆留下的疤<br>你的眼中 明暗交杂 一笑生花<br>我仍感叹于世界之大<br>也沉醉于儿时情话<br>不剩真假 不做挣扎 无谓笑话<br>我终将青春还给了她<br>连同指尖弹出的盛夏<br>心之所动 就随风去了<br>以爱之名 你还愿意吗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="随笔" scheme="http://lisuisheng.github.io/blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
