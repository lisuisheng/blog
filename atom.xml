<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsuis的博客</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://lisuisheng.github.io/blog/"/>
  <updated>2019-05-11T14:14:22.015Z</updated>
  <id>http://lisuisheng.github.io/blog/</id>
  
  <author>
    <name>Lsuis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>StackStorm安装及与Zabbix平台集成</title>
    <link href="http://lisuisheng.github.io/blog/2019/05/10/Integration-StackStorm-Zabbix-1/"/>
    <id>http://lisuisheng.github.io/blog/2019/05/10/Integration-StackStorm-Zabbix-1/</id>
    <published>2019-05-10T14:00:03.000Z</published>
    <updated>2019-05-11T14:14:22.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="StackStorm安装与配置"><a href="#StackStorm安装与配置" class="headerlink" title="StackStorm安装与配置"></a>StackStorm安装与配置</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>StackStorm对系统的要求非常严格，目前支持的操作系统及版本如下表所示：</p><table><thead><tr><th>Linux</th><th>Vagrant Box</th><th>Amazon AWS AMI</th></tr></thead><tbody><tr><td>Ubuntu 14.04</td><td>bento/ubuntu-14.04</td><td>Ubuntu Server 14.04 LTS(HVM)</td></tr><tr><td>Ubuntu 16.04</td><td>bento/ubuntu-16.04</td><td>Ubuntu 16.04 LTS - Xenial(HVM)</td></tr><tr><td>RHEL7/CentOS 7</td><td>bento/centos-7.2</td><td>Red Hat Enterprise Linux(RHEL) 7.2 (HVM)</td></tr><tr><td>RHEL6/CentOS 6</td><td>bento/centos-6.7</td><td>Red Hat Enterprise Linux (RHEL) 6 (HVM)</td></tr></tbody></table><p>这里我们选用了CentOS 7 作为主机的操作系统。</p><h4 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h4><p>默认情况下，StackStorm 和相关服务将使用下面这些 TCP 端口:</p><ul><li>nginx (80, 443)</li><li>mongodb (27017)</li><li>rabbitmq (4369, 5672, 25672) </li><li>postgresql (5432)</li><li>st2auth (9100)</li><li>st2api (9101)</li><li>st2stream (9102)</li></ul><h4 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h4><p>必须的依赖软件包括 RabbitMQ、MongoDB、PostgreSQL，可选的依赖软件如下:</p><ul><li>nginx 用于 SSL 终结、反向代理 API 端点和服务</li><li>并发策略(Policies)使用的 Redis 或者 Zookeeper </li><li>Extreme Workflow Composer 中 LDAP 认证的 LDAP</li></ul><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>StackStorm提供多种手动安装的方式，可按照个人定制需求选择特定的安装方式。不需要特制需求的，可采用单行安装的方式。这里我们采用这种快速安装的方法来安装StackStorm。</p><ol><li><p>安装curl，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install curl nss</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令下载StackStorm的安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://stackstorm.com/packages/install.sh | bash -s -- --user=st2admin -- password=&apos;Ch@ngeMe&apos;</span><br></pre></td></tr></table></figure></li></ol><p>脚本将自动下载并安装StackStorm，完成后可通过浏览器访问WebUI。在CentOS 7 上有可能因为防火墙问题导致访问失败，需要对防火墙做一些设置。</p><h3 id="StackStorm配置"><a href="#StackStorm配置" class="headerlink" title="StackStorm配置"></a>StackStorm配置</h3><p>StackStorm 配置文件位于/etc/st2/st2.conf</p><p>一般使用默认的配置即可，如需特定配置可参考官方文档。</p><h2 id="StackStorm与Zabbix集成"><a href="#StackStorm与Zabbix集成" class="headerlink" title="StackStorm与Zabbix集成"></a>StackStorm与Zabbix集成</h2><h3 id="StackStorm与Zabbix集成创建和配置"><a href="#StackStorm与Zabbix集成创建和配置" class="headerlink" title="StackStorm与Zabbix集成创建和配置"></a>StackStorm与Zabbix集成创建和配置</h3><p>在StackStorm上集成Zabbix需要用到官方提供的集成包，集成包的<a href="https://github.com/StackStorm-Exchange/stackstorm-zabbix" target="_blank" rel="noopener">github仓库</a>，下载后我们根据提供的指南进行安装和配置。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>执行下面的命令，安装zabbix的集成包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># st2 pack install zabbix</span><br></pre></td></tr></table></figure></p><h4 id="注册StackStorm的报警媒介"><a href="#注册StackStorm的报警媒介" class="headerlink" title="注册StackStorm的报警媒介"></a>注册StackStorm的报警媒介</h4><p>在包内提供的虚拟环境下执行 register_st2_config_to_zabbix.py 脚本，脚本会在zabbix平台上自动注册一个新的报警媒介（即在zabbix的平台上添加一个stackstorm的报警媒介）。中括号部分请将其换成自己安装zabbix的host的地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># /opt/stackstorm/virtualenvs/zabbix/bin/python /opt/stackstorm/packs/zabbix/tools/register_st2_config_to_zabbix.py -z [http://zabbix-host/zabbix] -u Admin -p zabbix</span><br></pre></td></tr></table></figure></p><p>当我们执行完这个脚本后，在zabbix的WebUI上面，点击“管理-&gt;报警媒介类型”后，可发现在列表的最下方StackStorm的报警媒介已经创建成功了。<br><img src="/blog/img/Zabbix&amp;St2_integration_1.png" alt="images"></p><h4 id="配置报警媒介"><a href="#配置报警媒介" class="headerlink" title="配置报警媒介"></a>配置报警媒介</h4><p>点击StackStorm，进入后我们看到如下的配置参数的页面：<br>每一栏的参数的意义如下：</p><ul><li>Name： 媒介名</li><li>Script： 媒介类型</li><li>Script Name： 脚本名</li><li>Script parameters: 脚本参数<br>在脚本参数中，{ALERT.SENDTO}、{ALERT.SUBJECT}、{ALERT.MESSAGE}这三个参数已经配好了，我们需要配置的是前面4个带有 CHANGE ME 字样的参数，第一个参数是stackstorm的api地址，第二个参数是认证的地址，这两个参数都可以在 <strong>/etc/st2/st2.conf</strong> 配置文件中找到。第三个、第四个参数分别是登录StackStorm的用户名和密码，将其填写上去就可以了。这里给出一个参考配置如下：<br><img src="/blog/img/Zabbix&amp;St2_integration_2.png" alt="images"></li></ul><h4 id="设置报警脚本"><a href="#设置报警脚本" class="headerlink" title="设置报警脚本"></a>设置报警脚本</h4><p>st2_dispatch.py 这个脚本会将Zabbix上的事件转发到StackStorm的服务器上。我们需要把这个脚本放到 Zabbix 媒介类型所映射的目录中。<br>可通过以下命令查找 Zabbix 的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># grep &apos;AlertScriptsPath&apos; /etc/zabbix/zabbix_server.conf</span><br></pre></td></tr></table></figure></p><p>经查找，报警脚本在Zabbix中存放的目录是：<strong>/usr/lib/zabbix/alertscripts</strong></p><p>接下来会出现两种的设置方式，如果安装的 Zabbix 和 StackStorm 在同一个主机上，我们使用以下命令将这个转发信息的脚本复制过去就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cp /opt/stackstorm/packs/zabbix/tools/scripts/st2_dispatch.py /usr/lib/zabbix/alertscripts/</span><br></pre></td></tr></table></figure></p><p>如果不是安装在同一个主机上的话，需要将脚本发送过去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># scp st2-node:/opt/stackstorm/packs/zabbix/tools/scripts/st2_dispatch.py ./</span><br><span class="line"># mv st2_dispatch.py /usr/lib/zabbix/alertscripts/</span><br></pre></td></tr></table></figure></p><p>按照不同情况将脚本放到对应的路径之后，我们需要设置脚本的执行环境，这里需要用到Python的包管理器 pip ，用 pip 为报警脚本的下载对应的依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pip install st2client</span><br></pre></td></tr></table></figure></p><p>安装好依赖后，对其配置参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># /usr/lib/zabbix/alertscripts/st2_dispatch.py \</span><br><span class="line">&gt; --st2-userid=st2admin \</span><br><span class="line">&gt; --st2-passwd=passwd \</span><br><span class="line">&gt; --st2-api-url=https://st2-node/api \</span><br><span class="line">&gt; --st2-auth-url=https://st2-node/auth</span><br></pre></td></tr></table></figure></p><p>userid、passwd参数对应StackStorm的用户名和密码。api-url和auth-url与刚刚在Zabbix平台上报警媒介页面上面的设置成一样。到了这一步，StackStorm和Zabbix的集成基本上就配置完成了。</p><h3 id="完善Zabbix的触发警报和转发设置"><a href="#完善Zabbix的触发警报和转发设置" class="headerlink" title="完善Zabbix的触发警报和转发设置"></a>完善Zabbix的触发警报和转发设置</h3><p>我们可以在Zabbix的平台上，点击“配置 -&gt; 动作”，找到“Dispatching to StackStorm”这个Action，点击名字我们可以对其做一些配置。</p><p>我们可以对其增加一些触发条件，当满足出发条件之后，会将警报转发到StackStorm上。这里我定义了一个触发条件：<em>触发器示警度 不等于 未分类</em> 。意思是只要警报的类别不是“未分类”都将触发转发的动作。我们可以产生一些警报，测试一下能否触发警报并转发到StackStorm上。<br><img src="/blog/img/Zabbix&amp;St2_integration_6.png" alt="images"><br>点击“配置 -&gt; 主机”，然后找到默认配置好的主机 Zabbix server，点击触发器。<br><img src="/blog/img/Zabbix&amp;St2_integration_7.png" alt="images"></p><p>进入触发器页面后，点击右上角的“创建触发器”进入创建页面。</p><p>在这里，我们给触发器起个名字，严重性选择除了“未分类”以外的任意一个。在表达式那里，点击右边的“添加”按钮。这里创建的表达式可以任意，只要满足条件触发警报即可。这里给出一个样例配置图：<br><img src="/blog/img/Zabbix&amp;St2_integration_9.png" alt="images"><br>然后，点击最下方的“添加”按钮，这样就成功创建了一个警报的触发器。约等待30秒之后，Zabbix平台会监控到这个警报的产生。我们返回到“监测 -&gt; 仪表板”页面。在“问题”那一栏会产生警报，同时在最后一列会有动作的触发，把鼠标移上去可以看到Zabbix向StackStorm转发了这个错误警告：<br><img src="/blog/img/Zabbix&amp;St2_integration_10.png" alt="images"><br>接下来我们打开StackStorm的WebUI，打开“Trigger”页面，在右侧栏找到”Zabbix -&gt; event_handler”。点击后，打开“INSTANCE”选项卡，点击第一条记录，我们就可以查询到刚刚Zabbix转发的那条报警记录。<br><img src="/blog/img/Zabbix&amp;St2_integration_11.png" alt="images"><br>至此，大概 StackStorm 和 Zabbix 的集成介绍也差不多了。当然，我们也可以在 StackStorm 上设置一些rules。例如，当刚刚 StackStorm 的 Trigger 接收到 Zabbix 之后，触发 rules 里面的某条规则，执行相对应的 Action。这里，提供一个样例：</p><ul><li>在 rules 中添加一条规则，内容是：当 Trigger 接收到Zabbix转发的报警后，执行一个 Action ，这个 Action 操作的内容是获取 Zabbix 主机的状态信息。（这个 Action 由集成包提供）如图：<br><img src="/blog/img/Zabbix&amp;St2_integration_12.png" alt="images"></li><li>再次模拟一次以上触发警报的过程，当 StackStorm 再次接收到警报后，执行 Action 获取主机状态。最后，状态获取这个Action执行的记录，可以在 “HISTORY” 中查到，如图：<br><img src="/blog/img/Zabbix&amp;St2_integration_13.png" alt="images"><br><img src="/blog/img/Zabbix&amp;St2_integration_14.png" alt="images"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Zabbix安装和简单配置（Zabbix v4.2, CentOS 7）</title>
    <link href="http://lisuisheng.github.io/blog/2019/05/10/Integration-StackStorm-Zabbix/"/>
    <id>http://lisuisheng.github.io/blog/2019/05/10/Integration-StackStorm-Zabbix/</id>
    <published>2019-05-10T06:16:37.000Z</published>
    <updated>2019-05-10T08:49:13.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Zabbix-安装"><a href="#Zabbix-安装" class="headerlink" title="Zabbix 安装"></a>Zabbix 安装</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作系统: CentOS 7</span><br><span class="line">MySQL: 5.7.26</span><br><span class="line">Nginx: 1.12.2</span><br><span class="line">PHP: 5.4.16</span><br></pre></td></tr></table></figure><p>关于版本的选择并没有特别的指定，根据自己的需要选择合适的版本即可。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><h4 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h4><p>官方文档中介绍了几种获取软件包的方式，这里我们采用了从二进制包安装的方式安装Zabbix，其他安装方式请移步<a href="https://www.zabbix.com/documentation/4.0/zh/manual/installation/getting_zabbix" target="_blank" rel="noopener">官方文档</a>。</p><ol><li><p>添加 Zabbix 软件仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rpm -ivh https://repo.zabbix.com/zabbix/4.2/rhel/7/x86_64/zabbix-release-4.2-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>Zabbix 前端需要额外的基础安装包。需要在运行 Zabbix 前端的系统中启用可选 rpms 的软件仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum-config-manager --enable rhel-7-server-optional-rpms</span><br></pre></td></tr></table></figure></li><li><p>安装 Zabbix server（适用于 RHEL7，在 RHEL 6 上弃用）并使用 MySQL 数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install zabbix-server-mysql</span><br></pre></td></tr></table></figure></li><li><p>（可选）安装 Zabbix proxy ：<br>Zabbix proxy是一个可以从一个或多个受监控设备采集监控数据并将信息发送到 Zabbix server 的进程，主要是代表 Zabbix server 工作。 所有收集的数据都在本地缓存，然后传输到 proxy 所属的 Zabbix server。部署Zabbix proxy 是可选的，但可能非常有利于分担单个 Zabbix server 的负载。由于笔者安装Zabbix并非用于生产环境，此步骤省略。<br>注意：使用proxy和server需要创建两个不同的数据库。</p></li></ol><h2 id="Zabbix配置"><a href="#Zabbix配置" class="headerlink" title="Zabbix配置"></a>Zabbix配置</h2><p>在获得所需软件包后，需要对Zabbix做导入初始数据、数据库配置、前端配置等简单设置。</p><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><ol><li><p>使用 MySQL 来导入 Zabbix server 的初始数据库 schema 和数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure></li><li><p>配置Zabbix server的数据库<br>编辑 zabbix_server.conf 文件以使用已创建的数据库。其中，DBPassword的参数输入刚刚创建数据库所使用的用户密码。其他采用默认设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/zabbix/zabbix_server.conf</span><br><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=&lt;password&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动Server进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service zabbix-server start</span><br></pre></td></tr></table></figure></li></ol><p>在系统启动时候自动启动zabbix server：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl enable zabbix-server</span><br></pre></td></tr></table></figure></p><h3 id="Zabbix-前端配置"><a href="#Zabbix-前端配置" class="headerlink" title="Zabbix 前端配置"></a>Zabbix 前端配置</h3><p>Zabbix 前端的 Apache 配置文件位于 <strong>/etc/httpd/conf.d/zabbix.conf</strong><br>其他参数设置官方默认已经配置好了，但是我们需要修改时区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">php_value max_execution_time 300</span><br><span class="line">php_value memory_limit 128M</span><br><span class="line">php_value post_max_size 16M</span><br><span class="line">php_value upload_max_filesize 2M</span><br><span class="line">php_value max_input_time 300</span><br><span class="line">php_value always_populate_raw_post_data -1</span><br><span class="line"># php_value date.timezone Europe/Riga</span><br></pre></td></tr></table></figure></p><p>取消 “date.timezone” 注释，并将其修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_value date.timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></p><h3 id="SeLinux配置"><a href="#SeLinux配置" class="headerlink" title="SeLinux配置"></a>SeLinux配置</h3><p>为简单其见，我们直接把SeLinux关闭了。但是实际出于安全的考虑，建议还是安装官方提供的文档进行配置。</p><ul><li><p>查询Selinux的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# getenforce</span><br><span class="line">Enforcing   # 启用状态</span><br></pre></td></tr></table></figure></li><li><p>配置selinux文件使其长期处于关闭状态，开机不启动   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sysconfig/selinux</span><br><span class="line">SELINUX=enforcing</span><br></pre></td></tr></table></figure></li><li><p>将 enforcing 改为 disable</p></li><li>重启服务器</li></ul><p><strong>待前端和 SELinux 配置完成后，需要重新启动 Apache web 服务器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service httpd restart</span><br></pre></td></tr></table></figure></p><h3 id="安装-Agent"><a href="#安装-Agent" class="headerlink" title="安装 Agent"></a>安装 Agent</h3><ul><li><p>运行以下命令以安装 Zabbix agent ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install zabbix-agent</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令以启动 Zabbix agent：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># service zabbix-agent start</span><br></pre></td></tr></table></figure></li></ul><p>因为我的主机上还安装了StackStorm，默认也在80端口提供web应用服务，因此在启动Zabbix的Web应用服务会出现端口已占用的情况，查询端口占用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -tunlp</span><br></pre></td></tr></table></figure></p><p>此时，需要更改Zabbix的Web服务的监听端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure></p><p>将监听的端口由80改为8080（或其他未占用端口）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Listen: Allows you to bind Apache to specific IP addresses and/or</span><br><span class="line"># ports, instead of the default. See also the &lt;VirtualHost&gt;</span><br><span class="line"># directive.</span><br><span class="line">#</span><br><span class="line"># Change this to Listen on specific IP addresses as shown below to</span><br><span class="line"># prevent Apache from glomming onto all bound IP addresses.</span><br><span class="line">#</span><br><span class="line">#Listen 12.34.56.78:80</span><br><span class="line">Listen 8080</span><br></pre></td></tr></table></figure></p><p>配置好以上的设置之后，通过浏览器访问127.0.0.1:8080/zabbix，即可看到Zabbix的欢迎页面。</p><h3 id="通过Web界面配置"><a href="#通过Web界面配置" class="headerlink" title="通过Web界面配置"></a>通过Web界面配置</h3><p><img src="/blog/img/zabbix_install_1.png" alt="images"><br><img src="/blog/img/zabbix_install_2.png" alt="images"><br><img src="/blog/img/zabbix_install_3.png" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>一文理解进程与线程的常见概念</title>
    <link href="http://lisuisheng.github.io/blog/2019/03/15/concurrent&amp;parallel/"/>
    <id>http://lisuisheng.github.io/blog/2019/03/15/concurrent&amp;parallel/</id>
    <published>2019-03-15T02:17:11.000Z</published>
    <updated>2019-03-15T10:25:30.592Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一文理解进程与线程的常见概念"><a href="#一文理解进程与线程的常见概念" class="headerlink" title="一文理解进程与线程的常见概念"></a>一文理解进程与线程的常见概念</h3><p>首先，进程和线程都是针对CPU工作时间段的描述。下面来看一下它们之间的区别。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是一个程序运行的时候被CPU抽象出来的概念，一个程序运行后被抽象为一个进程。当计算机执行一个程序的时候，必然会产生一个进程。也就是说，一个程序的执行<strong>至少有一个进程</strong>。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程至少拥有一个线程。线程的划分尺度小于进程，使得多线程程序具有更高的并发性。在一个进程中，可能被划分为多个线程，它可以与同进程中的其他线程共享数据。在进程中，有些程序流程块是可以乱序执行的，并且这个代码块可以同时被多次执行。实际上，这样的代码块就是线程体。线程是进程中乱序执行的代码流程。</p><blockquote><p>通过栗子了解进程和线程的特点：<br>进程 -&gt; 火车<br>线程 -&gt; 车厢</p><ol><li>一列火车可能有多个车厢（一个进程可以有多个线程）</li><li>乘客不能在行驶中从一列火车跳到另一列上（进程间数据不共享）</li><li>乘客可以在一列火车上去往各个车厢（同一进程下的线程数据共享）</li><li>一列火车抛锚了不影响另外一列火车，但是一节车厢断掉了会影响一整列火车（进程间不会相互影响，但一个线程挂掉会导致整个进程奔溃）</li></ol></blockquote><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p>在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务。目前的大多数计算机的操作系统都是多任务系统，能够管理多个进程的运行。这些任务之间互相不受影响，例如我们可以一边上网，一边打印文档。</p><p>当然，说到这里，还应谈及到并行与并发。对于计算机来说，一个单核的CPU原则上只能同时执行一个任务（进程）。假设CPU上有多个核的话，就可以同时执行多个任务。例如，4核的CPU可以同时执行4个任务（进程）。一个核执行一个任务，4个任务同时执行这个时候就叫做并行处理。</p><p>但是在实际上，我们计算机的CPU性能是非常的强大，强大到其他硬件的运行速度都只能望其项背。在执行任务当中，CPU处理任务的时间是非常短的。假设出现一个CPU处理一个任务的时候，此时CPU大多数的时间都处于空闲状态（实际上是在等待其他硬件执行操作），从而造成性能资源大大的浪费。</p><p>因此，并发处理成为了充分利用CPU资源的手段。当多个线程同时运行的时候，这样的执行模式称为并发处理。简单并发处理的算法如“时间片轮转进程调度算法”，它的思想简单介绍如下：在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何一个时间内有且仅有一个进程占有CPU。</p><p>简单的总结一下，如果进程数小于CPU数，则不同的进程可以分配给不同的CPU来运行，这样，多个进程就是真正同时运行的，这便是并行。但如果进程数大于CPU数，则仍然需要使用并发技术。<br><img src="/blog/img/concurrent&amp;parallel.jpg" alt="images"></p><p><em>附图来源于知乎，侵删。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Hyperledger基本概念及环境部署</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/13/hyperledgerConcept/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/13/hyperledgerConcept/</id>
    <published>2019-02-13T07:44:09.000Z</published>
    <updated>2019-02-13T11:51:55.589Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="区块链学习笔记"><a href="#区块链学习笔记" class="headerlink" title="区块链学习笔记"></a>区块链学习笔记</h2><h3 id="共享账本"><a href="#共享账本" class="headerlink" title="共享账本"></a>共享账本</h3><ol><li>世界状态：描述账本特定时间点的状态，是账本的数据库。</li><li>交易记录：记录产生世界状态当前值的所有交易，是世界状态的更新历史。</li><li>账本：世界状态数据库和交易历史记录的集合。</li></ol><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><ol><li>chaincode</li><li>只访问账本的数据库组件和世界状态，不会查询交易记录。目前支持语言：GO</li></ol><h3 id="fabric环境配置"><a href="#fabric环境配置" class="headerlink" title="fabric环境配置"></a>fabric环境配置</h3><ol><li>Git</li><li>Go - 1.10.x版本</li><li>Docker - 17.06.2-ce版本或以上</li><li>Docker Compose - 1.14.0版本或以上</li><li>Pip 安装方法：sudo apt-get install python-pip</li><li>过高的docker和docker-compose环境和fabric1.0不兼容</li><li>fabric v1.0.0 使用 Docker - 17.06.2-ce， docker-compose - 1.12.0</li><li>ubuntu系统有兼容问题？？</li></ol><h3 id="go环境的配置"><a href="#go环境的配置" class="headerlink" title="go环境的配置"></a>go环境的配置</h3><ol><li><p>下载golang：</p><pre><code>https://studygolang.com/dl</code></pre></li><li><p>解压并移动到/usr/local/go中</p><pre><code>sudo tar -zvxf go1.6.2.linux-amd64.tar.gzsudo mv go /usr/local/go</code></pre></li><li><p>设置环境变量</p><pre><code>sudo gedit /etc/profileexport GOROOT=/usr/local/go  #设置为go安装的路径export GOPATH=$HOME/gocode   #默认安装包的路径export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</code></pre></li><li><p>应用环境</p><pre><code>source /etc/profile</code></pre></li></ol><h3 id="拉取Fabric源码"><a href="#拉取Fabric源码" class="headerlink" title="拉取Fabric源码"></a>拉取Fabric源码</h3><pre><code>git clone https://github.com/hyperledger/fabric.git</code></pre><h3 id="编译configtxgen工具"><a href="#编译configtxgen工具" class="headerlink" title="编译configtxgen工具"></a>编译configtxgen工具</h3><pre><code>cd $GOPATH/src/github.com/hyperledger/fabricmake configtxgen# 如果出错：&apos;ltdl.h&apos; file not foundsudo apt install libtool libltdl-dev# 然后再运行makemake configtxgen</code></pre><h3 id="测试e2e-cli"><a href="#测试e2e-cli" class="headerlink" title="测试e2e_cli"></a>测试e2e_cli</h3><ol><li><p>执行如下脚本：</p><pre><code>./network_setup.sh up</code></pre></li></ol><pre><code>这个做了如下操作：1. 编译生成Fabric公私钥、证书的程序，程序在目录：fabric/release/linux-amd64/bin2. 基于configtx.yaml生成创世区块和通道相关信息，并保存在channel-artifacts文件夹。3. 基于crypto-config.yaml生成公私钥和证书信息，并保存在crypto-config文件夹中。4. 基于docker-compose-cli.yaml启动1Orderer+4Peer+1CLI的Fabric容器。5. 在CLI启动的时候，会运行scripts/script.sh文件，这个脚本文件包含了创建Channel，加入Channel，安装Example02，运行Example02等功能。</code></pre><p><img src="/blog/img/区块链技术实现.png" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="区块链" scheme="http://lisuisheng.github.io/blog/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>关于使用hexo框架站内搜索的一些坑</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/13/searhPlugsDebug/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/13/searhPlugsDebug/</id>
    <published>2019-02-13T06:25:50.000Z</published>
    <updated>2019-02-13T14:31:07.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="搜索功能不能使用，提示content-json文件找不到"><a href="#搜索功能不能使用，提示content-json文件找不到" class="headerlink" title="搜索功能不能使用，提示content.json文件找不到"></a>搜索功能不能使用，提示content.json文件找不到</h2><p>一般出现这个错误的原因有两个：</p><h3 id="1-没有安装hexo-generator-json-content插件"><a href="#1-没有安装hexo-generator-json-content插件" class="headerlink" title="1. 没有安装hexo-generator-json-content插件"></a>1. 没有安装hexo-generator-json-content插件</h3><p><strong>解决方法：</strong><br>进入<u><strong>博客的根目录</strong></u>，使用以下命令安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-generator-json-content -S</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：这个插件一定要在博客的根目录中安装</p><h3 id="2-config-yml配置不正确"><a href="#2-config-yml配置不正确" class="headerlink" title="2. _config.yml配置不正确"></a>2. _config.yml配置不正确</h3><p><strong>解决方法：</strong><br>在博客根目录的_config.yml或者主题目录下的_config.yml添加相对应的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 搜索</span><br><span class="line">jsonContent:</span><br><span class="line">  searchLocal: true</span><br><span class="line">  searchGoogle: false</span><br><span class="line">  posts:</span><br><span class="line">    title: true</span><br><span class="line">    text: true</span><br><span class="line">    content: true</span><br><span class="line">    categories: false</span><br><span class="line">    tags: false</span><br></pre></td></tr></table></figure></p><p><strong>请注意：</strong><br>博主看过很多网上的帖子和博客都说一定要把以上的 jsonContent 配置在根目录的 <code>_config.yml</code>。然而亲测并非如此，写在主题目录的 <code>_config.yml</code>一样生效。但是，以上的 jsonContent 的配置仅供参考，实际中要对应博客中的search.js文件配置，否则浏览器依然会报错。</p><h3 id="3-博客的目录结构问题"><a href="#3-博客的目录结构问题" class="headerlink" title="3. 博客的目录结构问题"></a>3. 博客的目录结构问题</h3><p>这个问题可能会出现在 <code>search.js</code>文件中，博主在debug的时候首先发现浏览器报错找不到 <code>content.json</code>文件，但是如果按照前两点的方法解决之后在我们使用命令 <code>hexo g</code>之后，在 public 目录下会自动生成 <code>content.json</code>文件。那么原因很有可能是执行 <code>search.js</code>中出的错误，紧接着浏览源码的时候留意到在加载 <code>content.json</code>中的路径不正确:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loadData(success) &#123;</span><br><span class="line">    if (!searchData) &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&apos;GET&apos;, &apos;/content.json&apos;, true);</span><br><span class="line">        </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p><strong>解决方法：</strong></p><ol><li>由于博主的博客是部署在子文件xxx/blog/下的，所以需将其改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loadData(success) &#123;</span><br><span class="line">    if (!searchData) &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&apos;GET&apos;, &apos;/blog/content.json&apos;, true);</span><br><span class="line">        </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ol><p>这样 <code>content.js</code>就可以顺利加载出来了。我们也会发现在浏览器预览的时候输入搜索条件也能正确显示搜索结果。<br><img src="/blog/img/successQuery.png" alt="images"><br>但此时如果点击搜索结果并不能正确的进入搜索结果页面。原因是最后拼接路径没有修改过来，因此继续在 <code>search.js</code>文件中修改对应的 path 路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function render(data) &#123;</span><br><span class="line">    var html = &apos;&apos;;</span><br><span class="line">    if (data.length) &#123;</span><br><span class="line">        html = data.map(function(post) &#123;</span><br><span class="line">            return tpl(searchTpl, &#123;</span><br><span class="line">                title: filter(post.title, &apos;title&apos;),</span><br><span class="line">                path: &apos;blog/&apos; + post.path,</span><br><span class="line">                content: filter(post.text, &apos;content&apos;)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>至此，本地搜索功能可以正常使用了。</p><ol start="2"><li>第二种解决的方案就是要把博客部署在根路径下，不要放在任何子文件夹下，只要和 <code>search.js</code>的路径对的上就没有问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>mvc和mvvm</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/13/mvc&amp;&amp;mvvm/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/13/mvc&amp;&amp;mvvm/</id>
    <published>2019-02-13T06:24:07.000Z</published>
    <updated>2019-02-13T11:53:46.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MVC-和-MVVM-基本原理"><a href="#MVC-和-MVVM-基本原理" class="headerlink" title="MVC 和 MVVM 基本原理"></a>MVC 和 MVVM 基本原理</h2><h3 id="MVC–分层设计模型"><a href="#MVC–分层设计模型" class="headerlink" title="MVC–分层设计模型"></a>MVC–分层设计模型</h3><ul><li>M模型层：负责操作数据库，执行对应的SQL语句，进行数据的增删改查</li><li>V视图层：用户操作界面</li><li>C控制层：封装具体业务逻辑处理的逻辑代码，只负责处理业务</li></ul><h3 id="MVVM—-前端开发模型"><a href="#MVVM—-前端开发模型" class="headerlink" title="MVVM—-前端开发模型"></a>MVVM—-前端开发模型</h3><ul><li>M：从后台服务器返回到前端页面的数据集（单独某个页面）</li><li>VM（核心）：调度器，分割了M和V。主要思想是为了让开发更加方便，因为MVVM提供了数据的双向绑定。双向绑定是由VM提供。</li><li>V：页面HTML结构</li></ul><p>附上两种模型的原理图及关系</p><p><img src="/blog/img/MVC和MVVM的基本原理图.png" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="技术" scheme="http://lisuisheng.github.io/blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2019最喜欢的一首歌～</title>
    <link href="http://lisuisheng.github.io/blog/2019/02/12/qifengle/"/>
    <id>http://lisuisheng.github.io/blog/2019/02/12/qifengle/</id>
    <published>2019-02-12T13:03:10.000Z</published>
    <updated>2019-03-15T08:46:59.533Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="aplayer-KPRiFOfF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"><pre class="aplayer-lrc-content">[00:03.82]起风了-吴青峰[00:07.29]我曾将青春翻涌成她[00:10.72]也曾指尖弹出盛夏[00:14.06]心之所动 且就随缘去吧[00:45.34]这一路上走走停停[00:48.86]顺着少年漂流的痕迹[00:51.78]迈出车站的前一刻[00:55.13]竟有些犹豫[00:58.30]不禁笑这近乡情怯[01:01.46]仍无可避免[01:04.06]而长野的天[01:05.63]依旧那么暖[01:07.27]风吹起了从前[01:09.58]从前初识这世间[01:12.59]万般流连[01:14.42]看着天边似在眼前[01:17.50]也甘愿赴汤蹈火去走它一遍[01:22.73]如今走过这世间[01:25.59]万般流连[01:27.53]翻过岁月不同侧脸[01:30.56]措不及防闯入你的笑颜[01:36.32]我曾难自拔于世界之大[01:40.52]也沉溺于其中梦话[01:43.87]不得真假 不做挣扎 不惧笑话[01:49.41]我曾将青春翻涌成她[01:53.06]也曾指尖弹出盛夏[01:56.31]心之所动 且就随缘去吧[02:02.54]逆着光行走 任风吹雨打[02:19.44]短短的路走走停停[02:22.70]也有了几分的距离[02:25.86]不知抚摸的是故事 还是段心情[02:32.17]也许期待的不过是 与时间为敌[02:37.96]再次看到你[02:39.57]微凉晨光里[02:41.28]笑得很甜蜜[02:43.59]从前初识这世间[02:46.72]万般流连[02:48.43]看着天边似在眼前[02:51.67]也甘愿赴汤蹈火去走它一遍[02:56.60]如今走过这世间[02:59.73]万般流连[03:01.50]翻过岁月不同侧脸[03:04.59]措不及防闯入你的笑颜[03:13.58]我曾难自拔于世界之大[03:17.72]也沉溺于其中梦话[03:20.93]不得真假 不做挣扎 不惧笑话[03:26.85]我曾将青春翻涌成她[03:30.46]也曾指尖弹出盛夏[03:33.57]心之所动 且就随缘去吧[03:41.40]晚风吹起你鬓间的白发[03:45.34]抚平回忆留下的疤[03:48.61]你的眼中 明暗交杂 一笑生花[03:55.78]我仍感叹于世界之大[03:59.66]也沉醉于儿时情话[04:02.73]不剩真假 不做挣扎 无谓笑话[04:08.91]我终将青春还给了她[04:12.68]连同指尖弹出的盛夏[04:16.12]心之所动 就随风去了[04:21.71]以爱之名 你还愿意吗[04:33.26]爱你我的大白菜！</pre></div><script>var ap = new APlayer({element: document.getElementById("aplayer-KPRiFOfF"),narrow: false,autoplay: true,showlrc: 2,music: {title: "起风了",author: "吴青峰",url: "http://poeg603m7.bkt.clouddn.com/1111.mp3",pic: "http://p1.music.126.net/aMVPsO00OqlVTS2yMH8RgA==/109951163785600029.jpg?param=130y130",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><blockquote><p>起风了</p><footer><strong>吴青峰</strong></footer></blockquote><p>我曾将青春翻涌成她<br>也曾指尖弹出盛夏<br>心之所动 且就随缘去吧<br>这一路上走走停停<br>顺着少年漂流的痕迹<br>迈出车站的前一刻<br>竟有些犹豫<br>不禁笑这近乡情怯<br>仍无可避免<br>而长野的天<br>依旧那么暖<br>风吹起了从前<br>从前初识这世间<br>万般流连<br>看着天边似在眼前<br>也甘愿赴汤蹈火去走它一遍<br>如今走过这世间<br>万般流连<br>翻过岁月不同侧脸<br>措不及防闯入你的笑颜<br>我曾难自拔于世界之大<br>也沉溺于其中梦话<br>不得真假 不做挣扎 不惧笑话<br>我曾将青春翻涌成她<br>也曾指尖弹出盛夏<br>心之所动 且就随缘去吧<br>逆着光行走 任风吹雨打<br>短短的路走走停停<br>也有了几分的距离<br>不知抚摸的是故事 还是段心情<br>也许期待的不过是 与时间为敌<br>再次看到你<br>微凉晨光里<br>笑得很甜蜜<br>从前初识这世间<br>万般流连<br>看着天边似在眼前<br>也甘愿赴汤蹈火去走它一遍<br>如今走过这世间<br>万般流连<br>翻过岁月不同侧脸<br>措不及防闯入你的笑颜<br>我曾难自拔于世界之大<br>也沉溺于其中梦话<br>不得真假 不做挣扎 不惧笑话<br>我曾将青春翻涌成她<br>也曾指尖弹出盛夏<br>心之所动 且就随缘去吧<br>晚风吹起你鬓间的白发<br>抚平回忆留下的疤<br>你的眼中 明暗交杂 一笑生花<br>我仍感叹于世界之大<br>也沉醉于儿时情话<br>不剩真假 不做挣扎 无谓笑话<br>我终将青春还给了她<br>连同指尖弹出的盛夏<br>心之所动 就随风去了<br>以爱之名 你还愿意吗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
      <category term="随笔" scheme="http://lisuisheng.github.io/blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
